---
id: migrate-9_3_x-to-9_4_x
title: 9.3.x 至 9.4.x
sidebar_position: 6
description: 如何將插件從 Grafana 9.3.x 遷移至 9.4.x。
keywords:
  - grafana
  - plugins
  - plugin
  - upgrading
  - updating
  - migration
---

# 將插件從 Grafana 9.3.x 版遷移至 9.4.x 版

請遵循以下說明，將插件從 Grafana 9.3.x 版遷移至 9.4.x 版。

## 支援新的導覽版面配置

首先，在 `custom.ini` 中啟用 `topnav` 功能旗標，以檢查您的插件在新的導覽版面配置中的呈現方式：

```ini
[feature_toggles]
enable = topnav
```

### 從 `onNavChanged` 遷移

如果您的插件使用 `onNavChanged` 回呼來通知 Grafana 其導覽模型和子頁面，您應該會看到這會導致重複的導覽元素。如果您停用 `topnav`，那麼它應該看起來和以前一樣。

如果啟用了 `topnav`，那麼我們需要更新插件以利用新的 `PluginPage` 元件。在這種情況下，我們不呼叫現在已被棄用的 `onNavChanged`。

### 切換至 `PluginPage` 元件

Grafana 現在從 `@grafana/runtime` 公開了一個新的 `PluginPage` 元件，它會掛接到新的導覽和頁面版面配置。當 `topnav` 功能被停用時，這個新元件也支援舊的頁面版面配置。

新的 `PluginPage` 元件也會處理呈現區段導覽。區段導覽可以包含其他核心區段和其他插件。為了控制在特定插件的區段導覽中顯示哪些頁面，Grafana 會使用在 `plugin.json` 中新增且 `addToNav` 設定為 `true` 的頁面。

若要使用此元件，只需將其包裝在您的頁面內容周圍：

```tsx
import { PluginPage } from '@grafana/runtime';

...

return (
  <PluginPage>
    {your page content here}
  </PluginPage>
);
```

Grafana 會查看 URL 以了解哪個插件和頁面應在區段導覽中處於作用中狀態。因此，此元件僅適用於您已在 `plugin.json` 中指定的頁面。然後 `PluginPage` 將根據 `plugin.json` 中指定的頁面名稱呈現一個頁首。

### 對於未在 `plugin.json` 中定義的頁面使用 `PluginPage`

`PluginPage` 元件還公開了一個 `pageNav` 屬性，它是一個 `NavModelItem`。對於未在 `plugin.json` 中定義的頁面（例如，個別項目頁面），`pageNav` 屬性很有用。您在 `pageNav` 模型中指定的 `text` 和 `description` 用於填入麵包屑導覽和頁首。

**範例：**

```tsx
const pageNav = {
  text: 'Write errors cortex-prod-04',
  description: 'Incident timeline and details'
};

return (
  <PluginPage pageNav={pageNav}>
    {your page content here}
  </PluginPage>
);
```

在麵包屑導覽和區段導覽中比對作用中頁面的方式取決於頁面路由是否為階層式的。如果您有一個列表頁面和一個項目頁面，那麼您需要將項目頁面設為列表頁面的子路由。此外，您還需要在 `plugin.json` 中指定列表頁面的 URL。

例如，您可能在 `/users` 有一個使用者列表。這表示特定使用者的項目頁面需要位於 `/users/:id`。這可能需要對您的路由進行一些重構。

### 將 `PluginPage` 與分頁搭配使用

您還可以透過在 `pageNav` 模型中指定 `children` 來建立具有分頁導覽的頁面，從而建立更深一層的階層。

**範例：**

```tsx
const pageNav = {
  text: 'My page',
  description: 'Incident timeline and details',
  url: '/a/myorgid-pluginname-app',
  children: [
    {
      url: '/a/myorgid-pluginname-app/tab1',
      text: 'Tab1',
      active: true,
    },
    {
      url: '/a/myorgid-pluginname-app/tab2',
      text: 'Tab1',
    },
  ],
};

return (
  <PluginPage pageNav={pageNav}>
    {your page content here}
  </PluginPage>
);
```

### 以向後相容的方式使用 `PluginPage`

如果您想保持與較舊版本 Grafana 的向後相容性，一種方法是實作 `PluginPage` 包裝器。如果 `PluginPage` 可用且 `topnav` 功能已啟用，則使用真正的 `PluginPage`。在其他情況下，則退回到每個插件目前正在執行的任何操作（例如呼叫 `onNavChanged`）。

**範例：**

```tsx
import { PluginPageProps, PluginPage as RealPluginPage, config } from '@grafana/runtime';

export const PluginPage = RealPluginPage && config.featureToggles.topnav ? RealPluginPage : PluginPageFallback;

function PluginPageFallback(props: PluginPageProps) {
  return props.children;
}
```

需要一個額外的步驟（和 `if` 區塊）來根據 `config.features.topnav` 是否為 `true` 來隱藏或顯示分頁。您的插件需要在 `useNavModel.ts` 檔案中包含這些變更：

```tsx
// useNavModel.ts

import { config } from '@grafana/runtime';

...

export function useNavModel({ meta, rootPath, onNavChanged }: Args) {
const { pathname, search } = useLocation();
useEffect(() => {
  if (config.featureToggles.topnav) {
    return;
  }
}, [config]);

...
```

## Go 的插件 SDK 中的轉發 HTTP 標頭

我們建議在擷取轉發的 HTTP 標頭時使用 `<request>.GetHTTPHeader` 或 `<request>.GetHTTPHeaders` 方法。有關用法範例，請參閱[為登入的使用者轉發 OAuth 身分](../../how-to-guides/data-source-plugins/add-authentication-for-data-source-plugins#add-an-oauth-20-proxy-route-to-your-plugin)、[為登入的使用者轉發 cookie](../../how-to-guides/data-source-plugins/add-authentication-for-data-source-plugins#forward-cookies-for-the-logged-in-user) 或[為登入的使用者轉發使用者標頭](../../how-to-guides/data-source-plugins/add-authentication-for-data-source-plugins#forward-user-header-for-the-logged-in-user)。

### 技術細節

Grafana SDK for Go [v0.147.0](https://github.com/grafana/grafana-plugin-sdk-go/releases/tag/v0.147.0) 引入了一個新的介面 [ForwardHTTPHeaders](https://pkg.go.dev/github.com/grafana/grafana-plugin-sdk-go@v0.147.0/backend#ForwardHTTPHeaders)，`QueryDataRequest`、`CheckHealthRequest` 和 `CallResourceRequest` 都實作了該介面。

Grafana v9.4.0 中新引入的轉發 HTTP 標頭是 `X-Grafana-User`、`X-Panel-Id`、`X-Dashboard-Uid`、`X-Datasource-Uid` 和 `X-Grafana-Org-Id`。在內部，我們為這些標頭加上 `http_` 前綴，並在 [CheckHealthRequest.Headers](https://pkg.go.dev/github.com/grafana/grafana-plugin-sdk-go@v0.147.0/backend#CheckHealthRequest) 和 [QueryDataRequest.Headers](https://pkg.go.dev/github.com/grafana/grafana-plugin-sdk-go@v0.147.0/backend#QueryDataRequest) 中以 `http_<HTTP header name>` 的形式傳送。

我們建議使用 [ForwardHTTPHeaders](https://pkg.go.dev/github.com/grafana/grafana-plugin-sdk-go@v0.147.0/backend#ForwardHTTPHeaders) 方法，這樣您可以保證能夠在不使用前綴的情況下操作 HTTP 標頭。也就是說，您可以操作 `X-Grafana-User`、`X-Panel-Id`、`X-Dashboard-Uid`、`X-Datasource-Uid` 和 `X-Grafana-Org-Id`。